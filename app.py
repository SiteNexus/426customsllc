import os
import logging
from flask import Flask, render_template, abort, url_for
from flask_frozen import Freezer
import frontmatter  # For parsing YAML frontmatter from markdown files
import markdown     # For converting markdown content to HTML

# --- Configuration ---
# Define the directory where content (markdown files) is stored
CONTENT_DIR = "content"
# Define the directory where static assets (CSS, JS, images) are stored
# Flask's default static folder is 'static', so this matches that convention.
STATIC_DIR = "static"
# Define the output directory for the frozen site (this is where Flask-Frozen will output files)
BUILD_DIR = "build"

# --- Logging Setup ---
# Configure basic logging.
# Level: INFO and above will be logged.
# Format: Includes timestamp, log level, and the message.
# For more advanced logging (e.g., to a file, rotating logs), you can expand this.
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()] # Log to console
)
logger = logging.getLogger(__name__) # Get a logger instance for this module

# --- Flask App Initialization ---
# Initialize the Flask application instance.
# static_folder tells Flask where to find static files like CSS, JS, images.
# template_folder defaults to 'templates', which is standard.
app = Flask(__name__, static_folder=STATIC_DIR)

# Secret key is good practice for Flask apps, though less critical for a purely static site generator
# as session management isn't typically used. For security, if this app were to grow,
# use a strong, randomly generated key and store it securely (e.g., environment variable).
app.config['SECRET_KEY'] = os.environ.get('FLASK_SECRET_KEY', 'default_dev_secret_key')

# --- Flask-Frozen Configuration ---
# Configure where Flask-Frozen should output the static files.
app.config['FREEZER_DESTINATION'] = BUILD_DIR
# Set the base URL for the site. This is important for generating correct absolute URLs
# if your site is hosted in a subdirectory or if you need absolute URLs for sitemaps, etc.
# For local testing, 'http://localhost/' is fine. For production, use your actual domain.
app.config['FREEZER_BASE_URL'] = os.environ.get('FREEZER_BASE_URL', 'http://localhost/')
# Optional: FREEZER_REMOVE_EXTRA_FILES = True will clean the BUILD_DIR before freezing.
# Be cautious with this if you have other files in BUILD_DIR not generated by Flask-Frozen.
app.config['FREEZER_REMOVE_EXTRA_FILES'] = False
# Optional: Ignore certain static files during freezing if needed (e.g., SCSS source files)
# app.config['FREEZER_STATIC_IGNORE'] = ['*.scss', '*.map']

# Initialize Flask-Frozen with the Flask app instance.
freezer = Freezer(app)

# --- Data Loading and Processing ---
# Global variable to store all loaded page data.
# Each item will be a dictionary containing frontmatter metadata and rendered HTML content.
PAGES_DATA = []

def load_and_process_pages():
    """
    Loads all markdown (.md) files from the CONTENT_DIR.
    For each file:
    1. Parses YAML frontmatter and markdown content.
    2. Converts the markdown content to HTML.
    3. Ensures essential metadata like 'slug' and 'title' are present, defaulting if necessary.
    4. Appends the processed page data (metadata dictionary + HTML content) to the global PAGES_DATA list.
    Logs the process and any errors encountered.
    """
    logger.info(f"Attempting to load pages from content directory: '{os.path.abspath(CONTENT_DIR)}'")
    if not os.path.isdir(CONTENT_DIR):
        logger.error(f"Content directory '{CONTENT_DIR}' not found. Please create it and add markdown files.")
        return [] # Return empty list if content directory doesn't exist

    loaded_pages_count = 0
    local_pages_data = [] # Use a local list to build up pages before assigning to global

    for filename in os.listdir(CONTENT_DIR):
        if filename.endswith(".md"):
            file_path = os.path.join(CONTENT_DIR, filename)
            logger.debug(f"Processing markdown file: {file_path}")
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    # python-frontmatter library loads YAML frontmatter and content
                    post = frontmatter.load(f)

                # Convert markdown content to HTML using the python-markdown library
                # You can add markdown extensions here if needed (e.g., for tables, fenced code blocks)
                # Example: extensions=['markdown.extensions.tables', 'markdown.extensions.fenced_code']
                html_content = markdown.markdown(post.content, extensions=['tables', 'fenced_code'])

                # The processed page data will be the frontmatter metadata dictionary
                page_info = post.metadata
                page_info['content_html'] = html_content  # Add the rendered HTML content
                page_info['original_filename'] = filename # Store original filename for reference

                # Ensure a 'slug' exists for URL generation.
                # If not provided in frontmatter, create one from the filename.
                if 'slug' not in page_info or not page_info['slug']:
                    page_info['slug'] = os.path.splitext(filename)[0].lower().replace(" ", "-")
                    logger.warning(
                        f"File '{filename}' is missing 'slug' in its frontmatter or slug is empty. "
                        f"Defaulting slug to: '{page_info['slug']}'."
                    )

                # Ensure a 'title' exists for display.
                # If not provided, create one from the slug.
                if 'title' not in page_info or not page_info['title']:
                    page_info['title'] = page_info['slug'].replace("-", " ").title()
                    logger.warning(
                        f"File '{filename}' is missing 'title' in its frontmatter or title is empty. "
                        f"Defaulting title to: '{page_info['title']}'."
                    )
                
                # Ensure 'layout' exists, defaulting to 'page' if not specified
                if 'layout' not in page_info or not page_info['layout']:
                    page_info['layout'] = 'page' # Default layout template name
                    logger.debug(f"File '{filename}' missing 'layout'. Defaulting to 'page'.")


                local_pages_data.append(page_info)
                loaded_pages_count += 1
                logger.debug(f"Successfully loaded and processed: {filename} (Slug: {page_info['slug']})")

            except Exception as e:
                # Log any error during file processing and skip the file
                logger.error(f"Error processing file {file_path}: {e}", exc_info=True)
        else:
            logger.debug(f"Skipping non-markdown file in content directory: {filename}")

    if loaded_pages_count > 0:
        logger.info(f"Successfully loaded and processed {loaded_pages_count} markdown pages.")
    else:
        logger.warning(f"No markdown pages were loaded from '{CONTENT_DIR}'. Check the directory and file extensions.")
    
    return local_pages_data

# Load pages when the application starts.
# This makes PAGES_DATA available globally to routes and other functions.
PAGES_DATA = load_and_process_pages()
logger.info(f"Total pages loaded: {len(PAGES_DATA)}")
# If PAGES_DATA is empty, log a warning.
if not PAGES_DATA:
    logger.warning("No pages were loaded. Ensure markdown files are present in the content directory.")

# --- Custom Template Filters ---
@app.template_filter('markdown')
def markdown_filter(s):
    """
    Converts a Markdown string to HTML.
    Usage in template: {{ my_markdown_string | markdown | safe }}
    """
    if s: # Ensure s is not None
        # You can configure markdown extensions here if needed globally for this filter
        # For example: return markdown.markdown(s, extensions=['fenced_code', 'tables'])
        return markdown.markdown(s, extensions=['tables', 'fenced_code'])
    return '' # Return empty string if input is None or empty



# --- Routes ---
@app.route("/")
def index():
    """
    Renders the homepage of the site.
    It attempts to find a page specifically designated as the homepage
    (e.g., by a slug like 'index' or 'home' in its frontmatter).
    If no specific homepage is found, it might render a generic index template
    or list all available pages (behavior can be customized in 'templates/index.html').
    """
    logger.info("Request received for index page ('/')")

    # Attempt to find a specific page designated as the homepage
    # Common slugs for homepages are 'index' or 'home'
    homepage_entry = next((p for p in PAGES_DATA if p.get("slug") == "index"), None)
    if not homepage_entry:
        homepage_entry = next((p for p in PAGES_DATA if p.get("slug") == "home"), None)

    if homepage_entry:
        logger.info(f"Rendering homepage using content from page with slug: '{homepage_entry['slug']}'")
        # Use the 'page.html' template (or a specific 'home.html' if you create one)
        # Pass all_pages for potential navigation generation in the base template
        return render_template("page.html", entry=homepage_entry, all_pages=PAGES_DATA)
    else:
        # Fallback if no specific 'index.md' or 'home.md' is found
        logger.warning("No specific homepage content file (index.md or home.md) found. "
                       "Rendering generic 'index.html' template with all pages list.")
        # 'templates/index.html' should be designed to handle this case,
        # e.g., by listing all pages or showing a default welcome message.
        return render_template("index.html", pages=PAGES_DATA, all_pages=PAGES_DATA)


@app.route("/<path:slug>/") # Using <path:slug> allows slugs with slashes (for nested content if ever needed)
def page(slug):
    """
    Renders a generic content page based on the provided slug.
    It searches the loaded PAGES_DATA for a page with a matching slug.
    If found, it renders the page using the 'page.html' template.
    If not found, it aborts with a 404 error.
    """
    logger.info(f"Request received for page with slug: '{slug}'")

    # Find the page data that matches the requested slug
    found_page = next((p for p in PAGES_DATA if p.get("slug") == slug), None)

    if found_page:
        page_title = found_page.get('title', 'N/A')
        logger.info(f"Rendering page for slug: '{slug}' (Title: '{page_title}')")
        # The 'page.html' template is used to render the content.
        # It will receive the 'entry' dictionary containing all frontmatter and the rendered HTML.
        # 'all_pages' is passed for navigation purposes (e.g., in a header included by base.html).
        return render_template("page.html", entry=found_page, all_pages=PAGES_DATA)
    else:
        # If no page with the given slug is found, trigger a 404 Not Found error.
        logger.warning(f"Page with slug '{slug}' not found. Returning 404 error.")
        abort(404)

# --- Error Handling ---
@app.errorhandler(404)
def page_not_found(error):
    """
    Custom error handler for 404 Not Found errors.
    Renders the '404.html' template.
    """
    logger.error(f"Handling 404 error for path: {error.description if hasattr(error, 'description') else 'N/A'}")
    # 'all_pages' can be passed to the 404 template if its base template uses it for navigation.
    return render_template('404.html', all_pages=PAGES_DATA), 404

@app.errorhandler(500)
def internal_server_error(error):
    """
    Custom error handler for 500 Internal Server Error.
    Renders the '500.html' template. (Optional: create this template)
    """
    logger.critical(f"Handling 500 internal server error: {error}", exc_info=True)
    return render_template('500.html', all_pages=PAGES_DATA), 500


# --- Flask-Frozen URL Generators ---
# This is crucial for Flask-Frozen to discover all dynamic URLs that need to be built.
@freezer.register_generator
def page_url_generator():
    """
    URL generator for Flask-Frozen.
    It yields all URLs for the dynamically generated pages based on their slugs.
    This ensures that `freezer.freeze()` will find and build static HTML files for all content pages.
    """
    logger.info("Flask-Frozen: Registering URLs for dynamic content pages via page_url_generator...")
    if not PAGES_DATA:
        logger.warning("Flask-Frozen page_url_generator: PAGES_DATA is empty. "
                       "This might happen if freeze is called before pages are loaded. "
                       "Consider ensuring pages are loaded earlier or handle this scenario if it's problematic.")
    
    for page_item in PAGES_DATA:
        slug = page_item.get('slug')
        if slug:
            logger.debug(f"Flask-Frozen: Yielding URL for page with slug: '{slug}'")
            # Use url_for to correctly generate the URL for the 'page' view function and its 'slug' argument.
            yield url_for('page', slug=slug)
        else:
            # This case should ideally be prevented by the defaulting logic in load_and_process_pages()
            logger.warning(f"Flask-Frozen: Page item titled '{page_item.get('title', 'Untitled')}' "
                           f"(Filename: {page_item.get('original_filename', 'N/A')}) is missing a slug. Cannot generate URL.")

# --- Main Execution Guard ---
# This block executes if the script is run directly (e.g., `python app.py`).
# It's primarily used for starting the Flask development server.
# For generating the static site, you would typically run a separate `build_static.py` script
# which imports `freezer` from this `app.py` and calls `freezer.freeze()`.
if __name__ == "__main__":
    logger.info("Starting Flask development server via __main__ block...")
    # Set debug=True for development. This enables auto-reloading on code changes and provides a debugger.
    # DO NOT run with debug=True in a production deployment environment.
    # Host '0.0.0.0' makes the server accessible from other devices on the network.
    # Port 5000 is the default Flask port.
    app.run(debug=True, host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))